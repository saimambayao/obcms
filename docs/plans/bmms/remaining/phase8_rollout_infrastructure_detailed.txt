================================================================================
BMMS PHASE 8 PREPARATION: FULL ROLLOUT INFRASTRUCTURE - DETAILED TASK BREAKDOWN
================================================================================

PHASE OVERVIEW:
---------------
Prepare comprehensive infrastructure and operational systems to support full 
rollout to 41 remaining MOAs (total 44 MOAs including pilot). This phase 
focuses on scaling, automation, monitoring, and support systems required for 
successful mass deployment.

PRIORITY: HIGH (Critical for BMMS success)
COMPLEXITY: High (Multi-faceted infrastructure preparation)
PREREQUISITES: 
- Phase 7 pilot completion with success metrics
- Pilot lessons learned documented
- Infrastructure capacity assessment completed

================================================================================
SECTION 1: INFRASTRUCTURE SCALING
================================================================================

[P8-INFRA-001] Server Capacity Planning
PRIORITY: CRITICAL
COMPLEXITY: Complex
DEPENDENCIES: Phase 7 pilot metrics
ESTIMATED EFFORT: Analysis phase

REQUIREMENTS:
- Analyze pilot phase resource utilization (CPU, memory, disk, network)
- Calculate per-MOA average resource consumption
- Project resource needs for 44 MOAs with 20% growth buffer
- Identify peak usage patterns (time of day, end of month reporting, etc.)
- Plan for seasonal variations (fiscal year end, policy cycles)
- Calculate cost projections (infrastructure, bandwidth, storage)

IMPLEMENTATION:
1. Collect Pilot Metrics:
   - Server CPU/memory utilization (hourly averages)
   - Database connection pool usage
   - Network bandwidth consumption
   - Storage growth rate
   - Redis cache hit rates
   - Celery task queue depths

2. Create Capacity Model:
   ```python
   # scripts/capacity_planning.py
   class CapacityPlanner:
       def __init__(self, pilot_metrics):
           self.pilot_metrics = pilot_metrics
           self.pilot_moas = 3
           self.target_moas = 44
       
       def calculate_resources(self):
           # Per-MOA averages from pilot
           cpu_per_moa = self.pilot_metrics['avg_cpu'] / self.pilot_moas
           memory_per_moa = self.pilot_metrics['avg_memory'] / self.pilot_moas
           
           # Project for 44 MOAs with 20% buffer
           target_cpu = cpu_per_moa * self.target_moas * 1.2
           target_memory = memory_per_moa * self.target_moas * 1.2
           
           return {
               'cpu_cores': math.ceil(target_cpu),
               'memory_gb': math.ceil(target_memory),
               'storage_gb': self.calculate_storage(),
               'bandwidth_gbps': self.calculate_bandwidth()
           }
   ```

3. Document Findings:
   File: docs/deployment/capacity_plan_phase8.md
   - Current vs. required resources
   - Scaling timeline (when to provision)
   - Cost breakdown
   - Risk assessment

VERIFICATION:
- [ ] Capacity plan reviewed by infrastructure team
- [ ] Cost projections approved by finance
- [ ] Scaling timeline documented
- [ ] Risk mitigation strategies defined

================================================================================

[P8-INFRA-002] Load Balancer Configuration
PRIORITY: CRITICAL
COMPLEXITY: Moderate
DEPENDENCIES: P8-INFRA-001
ESTIMATED EFFORT: Implementation phase

REQUIREMENTS:
- Configure load balancer for high availability
- Implement health checks with automatic failover
- Set up SSL/TLS termination
- Configure sticky sessions for Django
- Implement rate limiting per organization
- Set up geographic routing (if multi-region)

IMPLEMENTATION:
1. Choose Load Balancer:
   Options:
   - Nginx + keepalived (on-premises)
   - HAProxy (on-premises)
   - Cloud LB (AWS ALB, Azure LB, GCP LB)

2. Configuration Example (Nginx):
   File: config/nginx/load_balancer.conf
   ```nginx
   upstream bmms_backend {
       least_conn;
       server bmms-app-01:8000 max_fails=3 fail_timeout=30s;
       server bmms-app-02:8000 max_fails=3 fail_timeout=30s;
       server bmms-app-03:8000 max_fails=3 fail_timeout=30s;
       keepalive 32;
   }
   
   server {
       listen 443 ssl http2;
       server_name bmms.barmm.gov.ph;
       
       ssl_certificate /etc/ssl/certs/bmms.crt;
       ssl_certificate_key /etc/ssl/private/bmms.key;
       ssl_protocols TLSv1.2 TLSv1.3;
       
       # Health check endpoint
       location /health/ {
           access_log off;
           proxy_pass http://bmms_backend;
       }
       
       # Rate limiting per organization
       limit_req_zone $http_x_organization_id zone=org_limit:10m rate=100r/s;
       limit_req zone=org_limit burst=200 nodelay;
       
       location / {
           proxy_pass http://bmms_backend;
           proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
           proxy_set_header X-Forwarded-Proto $scheme;
           proxy_set_header Host $host;
           
           # Sticky sessions
           proxy_cookie_path / "/; HTTPOnly; Secure; SameSite=Strict";
       }
   }
   ```

3. Health Check Endpoint:
   File: src/common/views/health.py
   ```python
   from django.http import JsonResponse
   from django.db import connection
   from django.core.cache import cache
   
   def health_check(request):
       """Load balancer health check endpoint."""
       checks = {
           'database': False,
           'cache': False,
           'celery': False
       }
       
       # Database check
       try:
           with connection.cursor() as cursor:
               cursor.execute("SELECT 1")
           checks['database'] = True
       except Exception:
           pass
       
       # Cache check
       try:
           cache.set('health_check', 'ok', 10)
           checks['cache'] = cache.get('health_check') == 'ok'
       except Exception:
           pass
       
       # Celery check (optional - check last heartbeat)
       try:
           from django_celery_beat.models import PeriodicTask
           checks['celery'] = PeriodicTask.objects.exists()
       except Exception:
           pass
       
       status = 200 if all(checks.values()) else 503
       return JsonResponse(checks, status=status)
   ```

VERIFICATION:
- [ ] Load balancer routes traffic evenly
- [ ] Health checks trigger automatic failover
- [ ] SSL/TLS certificates valid and renewed
- [ ] Rate limiting prevents abuse
- [ ] Session stickiness works correctly
- [ ] Failover time < 10 seconds

================================================================================

[P8-INFRA-003] Database Connection Pooling
PRIORITY: CRITICAL
COMPLEXITY: Moderate
DEPENDENCIES: P8-INFRA-001
ESTIMATED EFFORT: Configuration phase

REQUIREMENTS:
- Configure PgBouncer for connection pooling
- Set appropriate pool sizes based on capacity planning
- Configure pool modes (session vs. transaction)
- Implement connection health checks
- Set up monitoring for pool exhaustion

IMPLEMENTATION:
1. Install PgBouncer:
   File: docker-compose.prod.yml
   ```yaml
   pgbouncer:
     image: pgbouncer/pgbouncer:latest
     environment:
       DATABASES_HOST: postgres
       DATABASES_PORT: 5432
       DATABASES_USER: bmms_user
       DATABASES_PASSWORD: ${DB_PASSWORD}
       DATABASES_DBNAME: bmms_prod
       PGBOUNCER_POOL_MODE: transaction
       PGBOUNCER_MAX_CLIENT_CONN: 1000
       PGBOUNCER_DEFAULT_POOL_SIZE: 25
       PGBOUNCER_MIN_POOL_SIZE: 10
       PGBOUNCER_RESERVE_POOL_SIZE: 5
       PGBOUNCER_SERVER_LIFETIME: 3600
       PGBOUNCER_SERVER_IDLE_TIMEOUT: 600
     ports:
       - "6432:6432"
     volumes:
       - ./config/pgbouncer/pgbouncer.ini:/etc/pgbouncer/pgbouncer.ini
       - ./config/pgbouncer/userlist.txt:/etc/pgbouncer/userlist.txt
   ```

2. Django Settings:
   File: src/obc_management/settings/production.py
   ```python
   DATABASES = {
       'default': {
           'ENGINE': 'django.db.backends.postgresql',
           'NAME': env('DB_NAME'),
           'USER': env('DB_USER'),
           'PASSWORD': env('DB_PASSWORD'),
           'HOST': env('DB_HOST', default='pgbouncer'),  # Point to PgBouncer
           'PORT': env('DB_PORT', default='6432'),
           'CONN_MAX_AGE': 0,  # Important for PgBouncer transaction pooling
           'OPTIONS': {
               'connect_timeout': 10,
               'options': '-c statement_timeout=30000'
           }
       }
   }
   ```

3. Monitoring Query:
   ```sql
   -- Check pool status
   SHOW POOLS;
   SHOW CLIENTS;
   SHOW SERVERS;
   
   -- Alert if pool utilization > 80%
   SELECT 
       database,
       user,
       cl_active,
       cl_waiting,
       sv_active,
       sv_idle,
       maxwait
   FROM pgbouncer.pools
   WHERE cl_active::float / GREATEST(sv_active + sv_idle, 1) > 0.8;
   ```

VERIFICATION:
- [ ] PgBouncer handles expected connection load
- [ ] No connection pool exhaustion under load
- [ ] Connection reuse rate > 90%
- [ ] Query performance unchanged
- [ ] Monitoring alerts configured

================================================================================

[P8-INFRA-004] Redis Cluster Setup
PRIORITY: HIGH
COMPLEXITY: Complex
DEPENDENCIES: P8-INFRA-001
ESTIMATED EFFORT: Implementation phase

REQUIREMENTS:
- Set up Redis cluster for high availability
- Configure Redis Sentinel for automatic failover
- Implement data persistence (RDB + AOF)
- Set up cache eviction policies
- Configure Celery to use Redis cluster

IMPLEMENTATION:
1. Redis Cluster Configuration:
   File: docker-compose.prod.yml
   ```yaml
   redis-master:
     image: redis:7-alpine
     command: redis-server /etc/redis/redis.conf
     volumes:
       - redis-master-data:/data
       - ./config/redis/master.conf:/etc/redis/redis.conf
     ports:
       - "6379:6379"
   
   redis-replica-1:
     image: redis:7-alpine
     command: redis-server /etc/redis/redis.conf
     volumes:
       - redis-replica-1-data:/data
       - ./config/redis/replica.conf:/etc/redis/redis.conf
     depends_on:
       - redis-master
   
   redis-sentinel-1:
     image: redis:7-alpine
     command: redis-sentinel /etc/redis/sentinel.conf
     volumes:
       - ./config/redis/sentinel.conf:/etc/redis/sentinel.conf
     depends_on:
       - redis-master
   ```

2. Redis Master Config:
   File: config/redis/master.conf
   ```conf
   # Persistence
   save 900 1
   save 300 10
   save 60 10000
   appendonly yes
   appendfsync everysec
   
   # Memory
   maxmemory 2gb
   maxmemory-policy allkeys-lru
   
   # Security
   requirepass ${REDIS_PASSWORD}
   
   # Performance
   tcp-backlog 511
   timeout 300
   tcp-keepalive 60
   ```

3. Django Cache Settings:
   File: src/obc_management/settings/production.py
   ```python
   CACHES = {
       'default': {
           'BACKEND': 'django_redis.cache.RedisCache',
           'LOCATION': [
               'redis://redis-sentinel-1:26379/0',
               'redis://redis-sentinel-2:26379/0',
               'redis://redis-sentinel-3:26379/0',
           ],
           'OPTIONS': {
               'CLIENT_CLASS': 'django_redis.client.SentinelClient',
               'SENTINEL_KWARGS': {
                   'password': env('REDIS_PASSWORD')
               },
               'CONNECTION_POOL_KWARGS': {
                   'max_connections': 50,
                   'retry_on_timeout': True
               },
               'COMPRESSOR': 'django_redis.compressors.zlib.ZlibCompressor',
           }
       }
   }
   
   # Celery with Redis Sentinel
   CELERY_BROKER_URL = 'sentinel://redis-sentinel-1:26379;sentinel://redis-sentinel-2:26379'
   CELERY_BROKER_TRANSPORT_OPTIONS = {
       'sentinel_kwargs': {'password': env('REDIS_PASSWORD')},
       'master_name': 'bmms-master'
   }
   ```

VERIFICATION:
- [ ] Redis cluster handles failover automatically
- [ ] Data persists across restarts
- [ ] Cache hit rate > 80%
- [ ] Celery tasks route correctly
- [ ] Sentinel monitoring active

================================================================================

[P8-INFRA-005] CDN Configuration for Static Files
PRIORITY: MEDIUM
COMPLEXITY: Moderate
DEPENDENCIES: None
ESTIMATED EFFORT: Configuration phase

REQUIREMENTS:
- Configure CDN for static files (CSS, JS, images)
- Set appropriate cache headers
- Implement cache invalidation strategy
- Configure geographic distribution
- Set up HTTPS for CDN

IMPLEMENTATION:
1. Django Static Files Configuration:
   File: src/obc_management/settings/production.py
   ```python
   # Static files with CDN
   STATIC_URL = env('CDN_URL', default='https://cdn.bmms.barmm.gov.ph/static/')
   STATIC_ROOT = '/var/www/bmms/static/'
   
   # Media files with CDN
   MEDIA_URL = env('CDN_MEDIA_URL', default='https://cdn.bmms.barmm.gov.ph/media/')
   MEDIA_ROOT = '/var/www/bmms/media/'
   
   # S3 Backend (if using cloud storage)
   if env.bool('USE_S3', default=False):
       AWS_ACCESS_KEY_ID = env('AWS_ACCESS_KEY_ID')
       AWS_SECRET_ACCESS_KEY = env('AWS_SECRET_ACCESS_KEY')
       AWS_STORAGE_BUCKET_NAME = env('AWS_STORAGE_BUCKET_NAME')
       AWS_S3_CUSTOM_DOMAIN = f'{AWS_STORAGE_BUCKET_NAME}.s3.amazonaws.com'
       AWS_S3_OBJECT_PARAMETERS = {
           'CacheControl': 'max-age=86400',  # 24 hours
       }
       
       STATIC_URL = f'https://{AWS_S3_CUSTOM_DOMAIN}/static/'
       STATICFILES_STORAGE = 'storages.backends.s3boto3.S3Boto3Storage'
       DEFAULT_FILE_STORAGE = 'storages.backends.s3boto3.S3Boto3Storage'
   ```

2. Nginx CDN Configuration:
   File: config/nginx/cdn.conf
   ```nginx
   server {
       listen 443 ssl http2;
       server_name cdn.bmms.barmm.gov.ph;
       
       root /var/www/bmms;
       
       # Cache static files aggressively
       location /static/ {
           expires 1y;
           add_header Cache-Control "public, immutable";
           add_header X-Content-Type-Options "nosniff";
           
           # Gzip compression
           gzip on;
           gzip_types text/css application/javascript image/svg+xml;
           gzip_min_length 1000;
       }
       
       # Cache media files moderately
       location /media/ {
           expires 30d;
           add_header Cache-Control "public";
           
           # Prevent hotlinking
           valid_referers none blocked bmms.barmm.gov.ph *.barmm.gov.ph;
           if ($invalid_referer) {
               return 403;
           }
       }
   }
   ```

3. Cache Invalidation Script:
   File: scripts/invalidate_cdn_cache.py
   ```python
   import boto3
   from django.conf import settings
   
   def invalidate_cdn_cache(paths=None):
       """Invalidate CloudFront cache for specified paths."""
       if not paths:
           paths = ['/static/*', '/media/*']
       
       client = boto3.client('cloudfront')
       response = client.create_invalidation(
           DistributionId=settings.CLOUDFRONT_DISTRIBUTION_ID,
           InvalidationBatch={
               'Paths': {
                   'Quantity': len(paths),
                   'Items': paths
               },
               'CallerReference': str(time.time())
           }
       )
       return response['Invalidation']['Id']
   ```

VERIFICATION:
- [ ] Static files load from CDN
- [ ] Cache headers set correctly
- [ ] Geographic distribution works
- [ ] HTTPS certificates valid
- [ ] Cache invalidation successful

================================================================================
SECTION 2: WAVE DEPLOYMENT SYSTEM
================================================================================

[P8-WAVE-001] Wave Planning Tool
PRIORITY: HIGH
COMPLEXITY: Moderate
DEPENDENCIES: Phase 7 lessons learned
ESTIMATED EFFORT: Development phase

REQUIREMENTS:
- Create tool to plan MOA rollout in waves
- Allow grouping MOAs by ministry type, size, or readiness
- Generate rollout schedules with dependencies
- Support wave reordering and adjustments
- Export wave plans for stakeholder review

IMPLEMENTATION:
1. Wave Model:
   File: src/organizations/models/wave.py
   ```python
   from django.db import models
   from django.core.validators import MinValueValidator
   
   class RolloutWave(models.Model):
       """Represents a group of MOAs to be onboarded together."""
       
       name = models.CharField(max_length=100)  # "Wave 1: Priority Ministries"
       wave_number = models.PositiveIntegerField(
           validators=[MinValueValidator(1)],
           help_text="Sequential wave number (1, 2, 3, ...)"
       )
       description = models.TextField(blank=True)
       
       # Scheduling
       planned_start_date = models.DateField()
       planned_end_date = models.DateField()
       actual_start_date = models.DateField(null=True, blank=True)
       actual_end_date = models.DateField(null=True, blank=True)
       
       # Status
       status = models.CharField(
           max_length=20,
           choices=[
               ('planned', 'Planned'),
               ('in_progress', 'In Progress'),
               ('completed', 'Completed'),
               ('cancelled', 'Cancelled')
           ],
           default='planned'
       )
       
       # Capacity
       max_organizations = models.PositiveIntegerField(
           default=5,
           help_text="Maximum MOAs in this wave"
       )
       
       # Prerequisites
       prerequisite_waves = models.ManyToManyField(
           'self',
           symmetrical=False,
           blank=True,
           help_text="Waves that must complete before this one starts"
       )
       
       created_at = models.DateTimeField(auto_now_add=True)
       updated_at = models.DateTimeField(auto_now=True)
       
       class Meta:
           ordering = ['wave_number']
           unique_together = ['wave_number']
       
       def __str__(self):
           return f"Wave {self.wave_number}: {self.name}"
       
       def can_start(self):
           """Check if prerequisites are met."""
           prereqs = self.prerequisite_waves.all()
           return all(wave.status == 'completed' for wave in prereqs)
       
       def organizations_count(self):
           """Count organizations in this wave."""
           return self.organizations.count()
   
   
   class OrganizationWaveAssignment(models.Model):
       """Assigns an organization to a rollout wave."""
       
       organization = models.OneToOneField(
           'organizations.Organization',
           on_delete=models.CASCADE,
           related_name='wave_assignment'
       )
       wave = models.ForeignKey(
           RolloutWave,
           on_delete=models.CASCADE,
           related_name='organizations'
       )
       
       # Readiness
       readiness_score = models.IntegerField(
           validators=[MinValueValidator(0), MaxValueValidator(100)],
           help_text="Readiness score (0-100)"
       )
       readiness_notes = models.TextField(blank=True)
       
       # Status
       onboarding_status = models.CharField(
           max_length=20,
           choices=[
               ('pending', 'Pending'),
               ('training_scheduled', 'Training Scheduled'),
               ('training_complete', 'Training Complete'),
               ('system_access_granted', 'System Access Granted'),
               ('onboarding_complete', 'Onboarding Complete')
           ],
           default='pending'
       )
       
       assigned_at = models.DateTimeField(auto_now_add=True)
       assigned_by = models.ForeignKey(
           'auth.User',
           on_delete=models.SET_NULL,
           null=True
       )
       
       class Meta:
           ordering = ['wave__wave_number', 'organization__name']
       
       def __str__(self):
           return f"{self.organization.name} - {self.wave.name}"
   ```

2. Wave Planning View:
   File: src/organizations/views/wave_planning.py
   ```python
   from django.contrib.auth.decorators import login_required
   from django.shortcuts import render, redirect
   from organizations.models import Organization, RolloutWave
   from organizations.forms import WavePlanningForm
   
   @login_required
   def wave_planning_dashboard(request):
       """Dashboard for planning rollout waves."""
       waves = RolloutWave.objects.prefetch_related(
           'organizations',
           'prerequisite_waves'
       ).all()
       
       unassigned_orgs = Organization.objects.filter(
           wave_assignment__isnull=True,
           is_active=True
       ).exclude(
           organization_type='pilot'
       )
       
       context = {
           'waves': waves,
           'unassigned_orgs': unassigned_orgs,
           'total_moas': Organization.objects.count(),
           'assigned_moas': Organization.objects.filter(
               wave_assignment__isnull=False
           ).count()
       }
       return render(request, 'organizations/wave_planning.html', context)
   
   
   @login_required
   def create_wave(request):
       """Create a new rollout wave."""
       if request.method == 'POST':
           form = WavePlanningForm(request.POST)
           if form.is_valid():
               wave = form.save()
               return redirect('wave_detail', wave_id=wave.id)
       else:
           # Auto-suggest next wave number
           last_wave = RolloutWave.objects.order_by('-wave_number').first()
           next_number = (last_wave.wave_number + 1) if last_wave else 1
           
           form = WavePlanningForm(initial={'wave_number': next_number})
       
       return render(request, 'organizations/wave_form.html', {'form': form})
   
   
   @login_required
   def assign_org_to_wave(request, org_id, wave_id):
       """Assign an organization to a wave."""
       org = Organization.objects.get(id=org_id)
       wave = RolloutWave.objects.get(id=wave_id)
       
       # Check capacity
       if wave.organizations_count() >= wave.max_organizations:
           messages.error(request, f"Wave {wave.wave_number} is at capacity")
           return redirect('wave_planning_dashboard')
       
       # Create assignment
       assignment = OrganizationWaveAssignment.objects.create(
           organization=org,
           wave=wave,
           assigned_by=request.user,
           readiness_score=50  # Default, can be updated later
       )
       
       messages.success(
           request,
           f"{org.name} assigned to {wave.name}"
       )
       return redirect('wave_planning_dashboard')
   ```

3. Wave Planning Template:
   File: src/templates/organizations/wave_planning.html
   ```html
   {% extends "base.html" %}
   
   {% block content %}
   <div class="container mx-auto px-4 py-8">
       <div class="flex justify-between items-center mb-6">
           <h1 class="text-3xl font-bold">Rollout Wave Planning</h1>
           <a href="{% url 'create_wave' %}" class="btn btn-primary">
               Create New Wave
           </a>
       </div>
       
       <!-- Progress Overview -->
       <div class="grid grid-cols-3 gap-4 mb-8">
           <div class="stat-card">
               <div class="stat-value">{{ total_moas }}</div>
               <div class="stat-label">Total MOAs</div>
           </div>
           <div class="stat-card">
               <div class="stat-value text-green-600">{{ assigned_moas }}</div>
               <div class="stat-label">Assigned to Waves</div>
           </div>
           <div class="stat-card">
               <div class="stat-value text-orange-600">
                   {{ total_moas|add:"-"|add:assigned_moas }}
               </div>
               <div class="stat-label">Unassigned</div>
           </div>
       </div>
       
       <!-- Waves Timeline -->
       <div class="mb-8">
           <h2 class="text-2xl font-bold mb-4">Rollout Timeline</h2>
           <div class="space-y-4">
               {% for wave in waves %}
               <div class="card {% if wave.status == 'completed' %}bg-green-50{% elif wave.status == 'in_progress' %}bg-blue-50{% endif %}">
                   <div class="flex items-center justify-between">
                       <div class="flex-1">
                           <h3 class="text-xl font-bold">{{ wave.name }}</h3>
                           <p class="text-gray-600">{{ wave.description }}</p>
                           <div class="mt-2 flex gap-4 text-sm">
                               <span>
                                   <strong>Start:</strong> 
                                   {{ wave.planned_start_date|date:"M d, Y" }}
                               </span>
                               <span>
                                   <strong>End:</strong> 
                                   {{ wave.planned_end_date|date:"M d, Y" }}
                               </span>
                               <span>
                                   <strong>MOAs:</strong> 
                                   {{ wave.organizations_count }}/{{ wave.max_organizations }}
                               </span>
                           </div>
                       </div>
                       <div class="flex items-center gap-2">
                           <span class="badge badge-{{ wave.status }}">
                               {{ wave.get_status_display }}
                           </span>
                           <a href="{% url 'wave_detail' wave.id %}" 
                              class="btn btn-sm btn-outline">
                               View Details
                           </a>
                       </div>
                   </div>
               </div>
               {% endfor %}
           </div>
       </div>
       
       <!-- Unassigned Organizations -->
       {% if unassigned_orgs %}
       <div>
           <h2 class="text-2xl font-bold mb-4">Unassigned Organizations</h2>
           <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
               {% for org in unassigned_orgs %}
               <div class="card">
                   <h3 class="font-bold">{{ org.name }}</h3>
                   <p class="text-sm text-gray-600">{{ org.get_organization_type_display }}</p>
                   <div class="mt-2">
                       <select class="form-select w-full" 
                               onchange="assignToWave({{ org.id }}, this.value)">
                           <option value="">Assign to wave...</option>
                           {% for wave in waves %}
                           <option value="{{ wave.id }}">{{ wave.name }}</option>
                           {% endfor %}
                       </select>
                   </div>
               </div>
               {% endfor %}
           </div>
       </div>
       {% endif %}
   </div>
   
   <script>
   function assignToWave(orgId, waveId) {
       if (!waveId) return;
       
       htmx.ajax('POST', `/organizations/assign-wave/${orgId}/${waveId}/`, {
           target: 'body',
           swap: 'outerHTML'
       });
   }
   </script>
   {% endblock %}
   ```

VERIFICATION:
- [ ] Waves can be created and organized
- [ ] MOAs can be assigned to waves
- [ ] Wave capacity limits enforced
- [ ] Timeline visualization clear
- [ ] Export functionality works

================================================================================

[P8-WAVE-002] MOA Grouping Algorithm
PRIORITY: MEDIUM
COMPLEXITY: Moderate
DEPENDENCIES: P8-WAVE-001
ESTIMATED EFFORT: Development phase

REQUIREMENTS:
- Algorithm to suggest optimal MOA groupings
- Consider ministry type, size, readiness, geography
- Balance waves for even resource utilization
- Respect dependencies between MOAs
- Allow manual override of suggestions

IMPLEMENTATION:
1. Grouping Algorithm:
   File: src/organizations/services/wave_grouping.py
   ```python
   from dataclasses import dataclass
   from typing import List, Dict
   from organizations.models import Organization, RolloutWave
   
   @dataclass
   class GroupingCriteria:
       """Criteria for grouping MOAs into waves."""
       max_per_wave: int = 5
       balance_by_type: bool = True
       balance_by_size: bool = True
       prioritize_ready: bool = True
       geographic_proximity: bool = False
   
   
   class WaveGroupingService:
       """Service for suggesting optimal MOA groupings."""
       
       def __init__(self, criteria: GroupingCriteria):
           self.criteria = criteria
       
       def suggest_groupings(self) -> List[Dict]:
           """Generate suggested wave groupings."""
           # Get unassigned MOAs
           orgs = Organization.objects.filter(
               wave_assignment__isnull=True,
               is_active=True
           ).exclude(organization_type='pilot')
           
           # Calculate readiness scores
           scored_orgs = []
           for org in orgs:
               score = self._calculate_readiness_score(org)
               scored_orgs.append({
                   'organization': org,
                   'readiness_score': score,
                   'size_score': self._calculate_size_score(org),
                   'type_priority': self._get_type_priority(org)
               })
           
           # Sort by readiness and priority
           if self.criteria.prioritize_ready:
               scored_orgs.sort(
                   key=lambda x: (x['readiness_score'], x['type_priority']),
                   reverse=True
               )
           
           # Group into waves
           waves = []
           current_wave = []
           
           for item in scored_orgs:
               if len(current_wave) >= self.criteria.max_per_wave:
                   waves.append(current_wave)
                   current_wave = []
               
               # Check wave balance
               if self._is_balanced_addition(current_wave, item):
                   current_wave.append(item)
               else:
                   # Start new wave if current would be imbalanced
                   if current_wave:
                       waves.append(current_wave)
                   current_wave = [item]
           
           # Add remaining orgs
           if current_wave:
               waves.append(current_wave)
           
           return waves
       
       def _calculate_readiness_score(self, org: Organization) -> int:
           """Calculate organizational readiness (0-100)."""
           score = 0
           
           # Has admin users (20 points)
           if org.users.filter(is_staff=True).exists():
               score += 20
           
           # Has active users (20 points)
           active_users = org.users.filter(
               last_login__gte=timezone.now() - timedelta(days=30)
           ).count()
           if active_users > 0:
               score += 20
           
           # Training completion (30 points)
           # TODO: Check training records when implemented
           score += 15  # Default partial score
           
           # Infrastructure ready (30 points)
           # Check if basic data exists
           if hasattr(org, 'beneficiaries') and org.beneficiaries.exists():
               score += 15
           if hasattr(org, 'programs') and org.programs.exists():
               score += 15
           
           return min(score, 100)
       
       def _calculate_size_score(self, org: Organization) -> int:
           """Calculate organization size score."""
           user_count = org.users.count()
           
           if user_count < 10:
               return 1  # Small
           elif user_count < 50:
               return 2  # Medium
           else:
               return 3  # Large
       
       def _get_type_priority(self, org: Organization) -> int:
           """Get priority based on organization type."""
           priority_map = {
               'ministry': 3,  # Highest priority
               'office': 2,
               'agency': 1
           }
           return priority_map.get(org.organization_type, 0)
       
       def _is_balanced_addition(
           self,
           current_wave: List[Dict],
           new_org: Dict
       ) -> bool:
           """Check if adding org maintains wave balance."""
           if not current_wave:
               return True
           
           if not self.criteria.balance_by_type:
               return True
           
           # Count types in current wave
           type_counts = {}
           for item in current_wave:
               org_type = item['organization'].organization_type
               type_counts[org_type] = type_counts.get(org_type, 0) + 1
           
           # Check if new org type is over-represented
           new_type = new_org['organization'].organization_type
           new_count = type_counts.get(new_type, 0) + 1
           
           # Allow if no type exceeds 60% of wave
           max_ratio = 0.6
           return new_count / (len(current_wave) + 1) <= max_ratio
   
   
   # Management command to generate suggestions
   # File: src/organizations/management/commands/suggest_wave_groupings.py
   from django.core.management.base import BaseCommand
   
   class Command(BaseCommand):
       help = 'Generate suggested wave groupings for MOA rollout'
       
       def add_arguments(self, parser):
           parser.add_argument(
               '--max-per-wave',
               type=int,
               default=5,
               help='Maximum organizations per wave'
           )
           parser.add_argument(
               '--balance-types',
               action='store_true',
               help='Balance organization types across waves'
           )
       
       def handle(self, *args, **options):
           criteria = GroupingCriteria(
               max_per_wave=options['max_per_wave'],
               balance_by_type=options['balance_types']
           )
           
           service = WaveGroupingService(criteria)
           waves = service.suggest_groupings()
           
           self.stdout.write(
               self.style.SUCCESS(
                   f"\nGenerated {len(waves)} suggested waves:"
               )
           )
           
           for i, wave in enumerate(waves, 1):
               self.stdout.write(f"\nWave {i}:")
               for item in wave:
                   org = item['organization']
                   self.stdout.write(
                       f"  - {org.name} "
                       f"(Readiness: {item['readiness_score']}, "
                       f"Type: {org.get_organization_type_display()})"
                   )
           
           # Ask if should create waves
           response = input("\nCreate these waves? (yes/no): ")
           if response.lower() == 'yes':
               self._create_waves(waves)
       
       def _create_waves(self, waves):
           """Create RolloutWave objects from suggestions."""
           for i, wave_orgs in enumerate(waves, 1):
               # Create wave
               wave = RolloutWave.objects.create(
                   name=f"Wave {i}",
                   wave_number=i,
                   description=f"Auto-generated wave {i}",
                   max_organizations=len(wave_orgs),
                   status='planned'
               )
               
               # Assign organizations
               for item in wave_orgs:
                   OrganizationWaveAssignment.objects.create(
                       organization=item['organization'],
                       wave=wave,
                       readiness_score=item['readiness_score']
                   )
               
               self.stdout.write(
                   self.style.SUCCESS(f"Created {wave.name}")
               )
   ```

VERIFICATION:
- [ ] Algorithm generates balanced waves
- [ ] Readiness scores calculated accurately
- [ ] Type distribution balanced
- [ ] Manual override possible
- [ ] Export suggestions for review

================================================================================

[P8-WAVE-003] Rollout Schedule Generator
PRIORITY: MEDIUM
COMPLEXITY: Simple
DEPENDENCIES: P8-WAVE-001, P8-WAVE-002
ESTIMATED EFFORT: Development phase

REQUIREMENTS:
- Generate detailed rollout schedule with dates
- Calculate training session schedules
- Account for holidays and blackout periods
- Support schedule adjustments
- Export to calendar formats (iCal, Google Calendar)

IMPLEMENTATION:
1. Schedule Generator Service:
   File: src/organizations/services/schedule_generator.py
   ```python
   from datetime import datetime, timedelta
   from typing import List, Dict
   from organizations.models import RolloutWave
   from django.utils import timezone
   
   class RolloutScheduleGenerator:
       """Generate detailed rollout schedules."""
       
       def __init__(
           self,
           start_date: datetime,
           wave_duration_days: int = 14,
           gap_between_waves_days: int = 7
       ):
           self.start_date = start_date
           self.wave_duration_days = wave_duration_days
           self.gap_between_waves_days = gap_between_waves_days
           self.holidays = self._load_holidays()
       
       def generate_schedule(self) -> List[Dict]:
           """Generate full rollout schedule."""
           waves = RolloutWave.objects.filter(
               status__in=['planned', 'in_progress']
           ).order_by('wave_number')
           
           schedule = []
           current_date = self.start_date
           
           for wave in waves:
               # Skip weekends and holidays
               current_date = self._next_business_day(current_date)
               
               # Calculate wave dates
               wave_start = current_date
               wave_end = self._add_business_days(
                   wave_start,
                   self.wave_duration_days
               )
               
               # Update wave dates
               wave.planned_start_date = wave_start.date()
               wave.planned_end_date = wave_end.date()
               wave.save()
               
               # Generate milestones
               milestones = self._generate_wave_milestones(
                   wave,
                   wave_start,
                   wave_end
               )
               
               schedule.append({
                   'wave': wave,
                   'start_date': wave_start,
                   'end_date': wave_end,
                   'milestones': milestones
               })
               
               # Move to next wave start
               current_date = self._add_business_days(
                   wave_end,
                   self.gap_between_waves_days
               )
           
           return schedule
       
       def _generate_wave_milestones(
           self,
           wave: RolloutWave,
           start: datetime,
           end: datetime
       ) -> List[Dict]:
           """Generate milestones for a wave."""
           duration = (end - start).days
           
           milestones = [
               {
                   'name': 'Wave Kickoff',
                   'date': start,
                   'description': 'Initial meeting with MOA leadership'
               },
               {
                   'name': 'Admin Training',
                   'date': start + timedelta(days=duration * 0.2),
                   'description': 'Train MOA administrators'
               },
               {
                   'name': 'User Training',
                   'date': start + timedelta(days=duration * 0.4),
                   'description': 'Train end users'
               },
               {
                   'name': 'System Access',
                   'date': start + timedelta(days=duration * 0.6),
                   'description': 'Grant production access'
               },
               {
                   'name': 'Go-Live',
                   'date': start + timedelta(days=duration * 0.8),
                   'description': 'MOA begins using system'
               },
               {
                   'name': 'Wave Completion',
                   'date': end,
                   'description': 'Final review and sign-off'
               }
           ]
           
           return milestones
       
       def _load_holidays(self) -> List[datetime]:
           """Load Philippine holidays."""
           # TODO: Integrate with holiday calendar
           return [
               datetime(2024, 1, 1),   # New Year
               datetime(2024, 4, 9),   # Araw ng Kagitingan
               datetime(2024, 5, 1),   # Labor Day
               datetime(2024, 6, 12),  # Independence Day
               datetime(2024, 8, 21),  # Ninoy Aquino Day
               datetime(2024, 11, 30), # Bonifacio Day
               datetime(2024, 12, 25), # Christmas
               datetime(2024, 12, 30), # Rizal Day
           ]
       
       def _next_business_day(self, date: datetime) -> datetime:
           """Get next business day (skip weekends/holidays)."""
           while date.weekday() in [5, 6] or date in self.holidays:
               date += timedelta(days=1)
           return date
       
       def _add_business_days(
           self,
           start: datetime,
           days: int
       ) -> datetime:
           """Add business days to a date."""
           current = start
           added = 0
           
           while added < days:
               current += timedelta(days=1)
               if current.weekday() not in [5, 6] and current not in self.holidays:
                   added += 1
           
           return current
       
       def export_to_ical(self, schedule: List[Dict]) -> str:
           """Export schedule to iCal format."""
           from icalendar import Calendar, Event
           
           cal = Calendar()
           cal.add('prodid', '-//BMMS Rollout Schedule//EN')
           cal.add('version', '2.0')
           
           for wave_data in schedule:
               wave = wave_data['wave']
               
               # Add wave event
               event = Event()
               event.add('summary', wave.name)
               event.add('dtstart', wave_data['start_date'])
               event.add('dtend', wave_data['end_date'])
               event.add('description', wave.description)
               cal.add_component(event)
               
               # Add milestones
               for milestone in wave_data['milestones']:
                   milestone_event = Event()
                   milestone_event.add('summary', milestone['name'])
                   milestone_event.add('dtstart', milestone['date'])
                   milestone_event.add('description', milestone['description'])
                   cal.add_component(milestone_event)
           
           return cal.to_ical().decode('utf-8')
   ```

2. Management Command:
   File: src/organizations/management/commands/generate_rollout_schedule.py
   ```python
   from django.core.management.base import BaseCommand
   from django.utils import timezone
   from organizations.services.schedule_generator import RolloutScheduleGenerator
   
   class Command(BaseCommand):
       help = 'Generate rollout schedule for all waves'
       
       def add_arguments(self, parser):
           parser.add_argument(
               '--start-date',
               type=str,
               help='Start date (YYYY-MM-DD)'
           )
           parser.add_argument(
               '--wave-duration',
               type=int,
               default=14,
               help='Duration of each wave in business days'
           )
           parser.add_argument(
               '--export-ical',
               action='store_true',
               help='Export to iCal format'
           )
       
       def handle(self, *args, **options):
           start_date_str = options.get('start_date')
           if start_date_str:
               start_date = datetime.strptime(start_date_str, '%Y-%m-%d')
           else:
               start_date = timezone.now()
           
           generator = RolloutScheduleGenerator(
               start_date=start_date,
               wave_duration_days=options['wave_duration']
           )
           
           schedule = generator.generate_schedule()
           
           # Display schedule
           self.stdout.write(self.style.SUCCESS("\nRollout Schedule:\n"))
           for wave_data in schedule:
               wave = wave_data['wave']
               self.stdout.write(
                   f"\n{wave.name}: "
                   f"{wave_data['start_date'].strftime('%Y-%m-%d')} to "
                   f"{wave_data['end_date'].strftime('%Y-%m-%d')}"
               )
               for milestone in wave_data['milestones']:
                   self.stdout.write(
                       f"  {milestone['date'].strftime('%Y-%m-%d')}: "
                       f"{milestone['name']}"
                   )
           
           # Export if requested
           if options['export_ical']:
               ical_content = generator.export_to_ical(schedule)
               filename = 'rollout_schedule.ics'
               with open(filename, 'w') as f:
                   f.write(ical_content)
               self.stdout.write(
                   self.style.SUCCESS(f"\nExported to {filename}")
               )
   ```

VERIFICATION:
- [ ] Schedule generated with correct dates
- [ ] Business days calculated properly
- [ ] Holidays excluded from schedule
- [ ] iCal export works correctly
- [ ] Schedule adjustable after generation

================================================================================

[P8-WAVE-004] Wave Status Tracking
PRIORITY: HIGH
COMPLEXITY: Moderate
DEPENDENCIES: P8-WAVE-001, P8-WAVE-003
ESTIMATED EFFORT: Development phase

REQUIREMENTS:
- Real-time tracking of wave progress
- Milestone completion tracking
- Blocker identification and escalation
- Progress reporting for stakeholders
- Automated status updates

IMPLEMENTATION:
1. Wave Progress Tracking Model:
   File: src/organizations/models/wave_progress.py
   ```python
   from django.db import models
   from django.contrib.auth import get_user_model
   
   User = get_user_model()
   
   class WaveMilestone(models.Model):
       """Milestones within a rollout wave."""
       
       wave = models.ForeignKey(
           'RolloutWave',
           on_delete=models.CASCADE,
           related_name='milestones'
       )
       
       name = models.CharField(max_length=200)
       description = models.TextField()
       planned_date = models.DateField()
       actual_date = models.DateField(null=True, blank=True)
       
       status = models.CharField(
           max_length=20,
           choices=[
               ('pending', 'Pending'),
               ('in_progress', 'In Progress'),
               ('completed', 'Completed'),
               ('delayed', 'Delayed'),
               ('blocked', 'Blocked')
           ],
           default='pending'
       )
       
       # Completion tracking
       completion_percentage = models.IntegerField(default=0)
       completed_by = models.ForeignKey(
           User,
           on_delete=models.SET_NULL,
           null=True,
           blank=True
       )
       
       order = models.PositiveIntegerField(default=0)
       
       class Meta:
           ordering = ['wave', 'order']
       
       def is_overdue(self):
           """Check if milestone is overdue."""
           if self.status == 'completed':
               return False
           return timezone.now().date() > self.planned_date
   
   
   class WaveBlocker(models.Model):
       """Track blockers preventing wave progress."""
       
       wave = models.ForeignKey(
           'RolloutWave',
           on_delete=models.CASCADE,
           related_name='blockers'
       )
       milestone = models.ForeignKey(
           WaveMilestone,
           on_delete=models.CASCADE,
           null=True,
           blank=True,
           related_name='blockers'
       )
       
       title = models.CharField(max_length=200)
       description = models.TextField()
       
       severity = models.CharField(
           max_length=20,
           choices=[
               ('low', 'Low - Minor delay expected'),
               ('medium', 'Medium - Significant delay possible'),
               ('high', 'High - Wave completion at risk'),
               ('critical', 'Critical - Wave must be paused')
           ]
       )
       
       status = models.CharField(
           max_length=20,
           choices=[
               ('open', 'Open'),
               ('investigating', 'Investigating'),
               ('resolved', 'Resolved'),
               ('wont_fix', "Won't Fix")
           ],
           default='open'
       )
       
       reported_by = models.ForeignKey(
           User,
           on_delete=models.SET_NULL,
           null=True,
           related_name='reported_blockers'
       )
       assigned_to = models.ForeignKey(
           User,
           on_delete=models.SET_NULL,
           null=True,
           blank=True,
           related_name='assigned_blockers'
       )
       
       created_at = models.DateTimeField(auto_now_add=True)
       resolved_at = models.DateTimeField(null=True, blank=True)
       
       class Meta:
           ordering = ['-severity', '-created_at']
       
       def __str__(self):
           return f"[{self.severity.upper()}] {self.title}"
   ```

2. Wave Progress Dashboard View:
   File: src/organizations/views/wave_progress.py
   ```python
   from django.contrib.auth.decorators import login_required
   from django.shortcuts import render, get_object_or_404
   from django.db.models import Count, Q, Avg
   from organizations.models import (
       RolloutWave, WaveMilestone, WaveBlocker, OrganizationWaveAssignment
   )
   
   @login_required
   def wave_progress_dashboard(request):
       """Dashboard showing progress of all waves."""
       waves = RolloutWave.objects.annotate(
           total_orgs=Count('organizations'),
           completed_orgs=Count(
               'organizations',
               filter=Q(organizations__onboarding_status='onboarding_complete')
           ),
           total_milestones=Count('milestones'),
           completed_milestones=Count(
               'milestones',
               filter=Q(milestones__status='completed')
           ),
           open_blockers=Count(
               'blockers',
               filter=Q(blockers__status='open')
           )
       ).all()
       
       # Calculate overall progress
       total_orgs = sum(w.total_orgs for w in waves)
       completed_orgs = sum(w.completed_orgs for w in waves)
       overall_progress = (
           (completed_orgs / total_orgs * 100) if total_orgs > 0 else 0
       )
       
       context = {
           'waves': waves,
           'overall_progress': overall_progress,
           'total_organizations': total_orgs,
           'completed_organizations': completed_orgs
       }
       return render(
           request,
           'organizations/wave_progress_dashboard.html',
           context
       )
   
   
   @login_required
   def wave_detail_progress(request, wave_id):
       """Detailed progress view for a specific wave."""
       wave = get_object_or_404(RolloutWave, id=wave_id)
       
       milestones = wave.milestones.all()
       organizations = wave.organizations.select_related('organization').all()
       blockers = wave.blockers.filter(status__in=['open', 'investigating'])
       
       # Calculate wave health score (0-100)
       health_score = calculate_wave_health(wave)
       
       context = {
           'wave': wave,
           'milestones': milestones,
           'organizations': organizations,
           'blockers': blockers,
           'health_score': health_score
       }
       return render(
           request,
           'organizations/wave_detail_progress.html',
           context
       )
   
   
   def calculate_wave_health(wave: RolloutWave) -> int:
       """Calculate wave health score (0-100)."""
       score = 100
       
       # Penalty for overdue milestones
       overdue_milestones = wave.milestones.filter(
           planned_date__lt=timezone.now().date(),
           status__in=['pending', 'in_progress']
       ).count()
       score -= overdue_milestones * 10
       
       # Penalty for open blockers
       critical_blockers = wave.blockers.filter(
           status='open',
           severity='critical'
       ).count()
       high_blockers = wave.blockers.filter(
           status='open',
           severity='high'
       ).count()
       score -= critical_blockers * 20
       score -= high_blockers * 10
       
       # Penalty for low org completion rate
       total_orgs = wave.organizations.count()
       if total_orgs > 0:
           completed_orgs = wave.organizations.filter(
               onboarding_status='onboarding_complete'
           ).count()
           completion_rate = completed_orgs / total_orgs
           
           # Expected completion rate based on time elapsed
           days_elapsed = (timezone.now().date() - wave.planned_start_date).days
           total_days = (wave.planned_end_date - wave.planned_start_date).days
           expected_rate = days_elapsed / total_days if total_days > 0 else 0
           
           if completion_rate < expected_rate:
               score -= (expected_rate - completion_rate) * 30
       
       return max(0, min(100, int(score)))
   ```

3. Automated Status Updates (Celery Task):
   File: src/organizations/tasks/wave_monitoring.py
   ```python
   from celery import shared_task
   from django.utils import timezone
   from organizations.models import (
       RolloutWave, WaveMilestone, WaveBlocker, OrganizationWaveAssignment
   )
   from common.utils.notifications import send_slack_notification
   
   @shared_task
   def update_wave_statuses():
       """Update wave statuses based on milestones and progress."""
       waves = RolloutWave.objects.filter(status='in_progress')
       
       for wave in waves:
           # Check if all milestones completed
           all_completed = not wave.milestones.filter(
               status__in=['pending', 'in_progress']
           ).exists()
           
           if all_completed:
               wave.status = 'completed'
               wave.actual_end_date = timezone.now().date()
               wave.save()
               
               # Notify stakeholders
               send_wave_completion_notification(wave)
               continue
           
           # Check for overdue milestones
           overdue_milestones = wave.milestones.filter(
               planned_date__lt=timezone.now().date(),
               status__in=['pending', 'in_progress']
           )
           
           if overdue_milestones.exists():
               for milestone in overdue_milestones:
                   milestone.status = 'delayed'
                   milestone.save()
               
               # Create blocker if not exists
               if not wave.blockers.filter(
                   title__icontains='overdue milestones',
                   status='open'
               ).exists():
                   WaveBlocker.objects.create(
                       wave=wave,
                       title='Overdue Milestones Detected',
                       description=f'{overdue_milestones.count()} milestones overdue',
                       severity='medium'
                   )
   
   
   @shared_task
   def check_wave_blockers():
       """Check for critical blockers and escalate."""
       critical_blockers = WaveBlocker.objects.filter(
           status='open',
           severity='critical'
       )
       
       for blocker in critical_blockers:
           # Check how long blocker has been open
           hours_open = (timezone.now() - blocker.created_at).total_seconds() / 3600
           
           if hours_open > 4:  # Escalate after 4 hours
               escalate_blocker(blocker)
   
   
   def send_wave_completion_notification(wave: RolloutWave):
       """Send notification when wave completes."""
       message = f"""
       Wave {wave.wave_number} completed!
       
       {wave.name}
       Organizations: {wave.organizations.count()}
       Duration: {wave.planned_start_date} to {wave.actual_end_date}
       """
       
       send_slack_notification(
           channel='#bmms-rollout',
           message=message,
           icon=':checkered_flag:'
       )
   
   
   def escalate_blocker(blocker: WaveBlocker):
       """Escalate critical blocker."""
       message = f"""
       CRITICAL BLOCKER ESCALATION
       
       Wave: {blocker.wave.name}
       Issue: {blocker.title}
       Duration: {blocker.created_at}
       
       Immediate attention required!
       """
       
       send_slack_notification(
           channel='#bmms-escalations',
           message=message,
           icon=':rotating_light:',
           mention='@channel'
       )
   ```

VERIFICATION:
- [ ] Wave progress tracked accurately
- [ ] Milestones update correctly
- [ ] Blockers identified and escalated
- [ ] Automated status updates work
- [ ] Health scores calculated correctly

================================================================================

[P8-WAVE-005] Rollout Cancellation Procedures
PRIORITY: MEDIUM
COMPLEXITY: Moderate
DEPENDENCIES: P8-WAVE-004
ESTIMATED EFFORT: Development phase

REQUIREMENTS:
- Procedures to pause or cancel wave rollout
- Data rollback capabilities
- User access revocation
- Communication templates for cancellation
- Lessons learned documentation

IMPLEMENTATION:
1. Wave Cancellation Service:
   File: src/organizations/services/wave_cancellation.py
   ```python
   from django.db import transaction
   from django.utils import timezone
   from organizations.models import (
       RolloutWave, OrganizationWaveAssignment, Organization
   )
   from django.contrib.auth import get_user_model
   
   User = get_user_model()
   
   class WaveCancellationService:
       """Service for pausing or cancelling wave rollout."""
       
       def __init__(self, wave: RolloutWave, cancelled_by: User):
           self.wave = wave
           self.cancelled_by = cancelled_by
       
       @transaction.atomic
       def pause_wave(self, reason: str):
           """Pause wave rollout (can be resumed)."""
           # Update wave status
           self.wave.status = 'paused'
           self.wave.save()
           
           # Log action
           WaveAction.objects.create(
               wave=self.wave,
               action_type='pause',
               reason=reason,
               performed_by=self.cancelled_by
           )
           
           # Notify all users in wave organizations
           self._notify_wave_pause(reason)
           
           return True
       
       @transaction.atomic
       def cancel_wave(
           self,
           reason: str,
           revoke_access: bool = False,
           rollback_data: bool = False
       ):
           """Cancel wave rollout (cannot be resumed)."""
           # Update wave status
           self.wave.status = 'cancelled'
           self.wave.actual_end_date = timezone.now().date()
           self.wave.save()
           
           # Revoke user access if requested
           if revoke_access:
               self._revoke_wave_access()
           
           # Rollback data if requested
           if rollback_data:
               self._rollback_wave_data()
           
           # Update organization assignments
           self.wave.organizations.update(
               onboarding_status='cancelled'
           )
           
           # Log action
           WaveAction.objects.create(
               wave=self.wave,
               action_type='cancel',
               reason=reason,
               performed_by=self.cancelled_by,
               metadata={
                   'revoke_access': revoke_access,
                   'rollback_data': rollback_data
               }
           )
           
           # Notify stakeholders
           self._notify_wave_cancellation(reason)
           
           return True
       
       def _revoke_wave_access(self):
           """Revoke system access for wave organizations."""
           for assignment in self.wave.organizations.all():
               org = assignment.organization
               
               # Disable organization
               org.is_active = False
               org.save()
               
               # Revoke user permissions
               User.objects.filter(organization=org).update(
                   is_active=False
               )
       
       def _rollback_wave_data(self):
           """Rollback data created during wave."""
           # This is a placeholder - actual implementation depends on
           # what data needs to be rolled back
           
           for assignment in self.wave.organizations.all():
               org = assignment.organization
               
               # Mark data as rolled back (don't delete for audit)
               # This would be customized based on your data model
               pass
       
       def _notify_wave_pause(self, reason: str):
           """Send notification about wave pause."""
           from common.utils.notifications import send_email_notification
           
           for assignment in self.wave.organizations.all():
               org_users = User.objects.filter(
                   organization=assignment.organization
               )
               
               for user in org_users:
                   send_email_notification(
                       to=user.email,
                       subject=f'BMMS Rollout Paused - {self.wave.name}',
                       template='organizations/emails/wave_paused.html',
                       context={
                           'wave': self.wave,
                           'reason': reason,
                           'user': user
                       }
                   )
       
       def _notify_wave_cancellation(self, reason: str):
           """Send notification about wave cancellation."""
           from common.utils.notifications import send_email_notification
           
           for assignment in self.wave.organizations.all():
               org_users = User.objects.filter(
                   organization=assignment.organization
               )
               
               for user in org_users:
                   send_email_notification(
                       to=user.email,
                       subject=f'BMMS Rollout Cancelled - {self.wave.name}',
                       template='organizations/emails/wave_cancelled.html',
                       context={
                           'wave': self.wave,
                           'reason': reason,
                           'user': user
                       }
                   )
   
   
   class WaveAction(models.Model):
       """Log of actions taken on waves."""
       wave = models.ForeignKey(
           RolloutWave,
           on_delete=models.CASCADE,
           related_name='actions'
       )
       action_type = models.CharField(
           max_length=20,
           choices=[
               ('pause', 'Paused'),
               ('resume', 'Resumed'),
               ('cancel', 'Cancelled')
           ]
       )
       reason = models.TextField()
       performed_by = models.ForeignKey(
           User,
           on_delete=models.SET_NULL,
           null=True
       )
       metadata = models.JSONField(default=dict)
       created_at = models.DateTimeField(auto_now_add=True)
   ```

2. Cancellation View:
   File: src/organizations/views/wave_cancellation.py
   ```python
   from django.contrib.auth.decorators import login_required
   from django.shortcuts import render, redirect, get_object_or_404
   from django.contrib import messages
   from organizations.models import RolloutWave
   from organizations.services.wave_cancellation import WaveCancellationService
   from organizations.forms import WaveCancellationForm
   
   @login_required
   def cancel_wave_view(request, wave_id):
       """View to cancel a wave."""
       wave = get_object_or_404(RolloutWave, id=wave_id)
       
       if request.method == 'POST':
           form = WaveCancellationForm(request.POST)
           if form.is_valid():
               service = WaveCancellationService(wave, request.user)
               
               action = form.cleaned_data['action']
               reason = form.cleaned_data['reason']
               
               if action == 'pause':
                   service.pause_wave(reason)
                   messages.success(
                       request,
                       f'Wave {wave.name} has been paused.'
                   )
               else:  # cancel
                   service.cancel_wave(
                       reason=reason,
                       revoke_access=form.cleaned_data['revoke_access'],
                       rollback_data=form.cleaned_data['rollback_data']
                   )
                   messages.warning(
                       request,
                       f'Wave {wave.name} has been cancelled.'
                   )
               
               return redirect('wave_progress_dashboard')
       else:
           form = WaveCancellationForm()
       
       context = {
           'wave': wave,
           'form': form
       }
       return render(request, 'organizations/wave_cancellation.html', context)
   ```

VERIFICATION:
- [ ] Wave can be paused and resumed
- [ ] Cancellation revokes access if requested
- [ ] Data rollback works correctly
- [ ] Notifications sent to affected users
- [ ] Actions logged for audit

================================================================================
SECTION 3: BATCH USER MANAGEMENT
================================================================================

[P8-USER-001] Bulk User Creation System
PRIORITY: CRITICAL
COMPLEXITY: Moderate
DEPENDENCIES: Phase 1 organizations app
ESTIMATED EFFORT: Development phase

REQUIREMENTS:
- CSV import for batch user creation
- Validation before import (duplicate detection, format checking)
- Role assignment during import
- Organization assignment automation
- Error handling and reporting
- Dry-run mode for testing

IMPLEMENTATION:
1. Bulk User Import Service:
   File: src/accounts/services/bulk_user_import.py
   ```python
   import csv
   from io import StringIO
   from typing import List, Dict, Tuple
   from django.contrib.auth import get_user_model
   from django.db import transaction
   from organizations.models import Organization
   from common.rbac.services import RBACService
   
   User = get_user_model()
   
   class BulkUserImportService:
       """Service for bulk user import from CSV."""
       
       REQUIRED_FIELDS = ['email', 'first_name', 'last_name', 'organization']
       OPTIONAL_FIELDS = ['role', 'phone_number', 'position']
       
       def __init__(self, dry_run: bool = False):
           self.dry_run = dry_run
           self.errors = []
           self.warnings = []
       
       def import_from_csv(self, csv_content: str) -> Dict:
           """Import users from CSV content."""
           # Parse CSV
           users_data = self._parse_csv(csv_content)
           if not users_data:
               return {
                   'success': False,
                   'errors': self.errors,
                   'created': 0,
                   'skipped': 0
               }
           
           # Validate data
           validated_users = self._validate_users(users_data)
           
           # Create users
           created_users = []
           skipped = 0
           
           if not self.dry_run:
               created_users, skipped = self._create_users(validated_users)
           else:
               # In dry run, just count valid users
               created_users = validated_users
           
           return {
               'success': len(self.errors) == 0,
               'errors': self.errors,
               'warnings': self.warnings,
               'created': len(created_users),
               'skipped': skipped,
               'users': created_users if self.dry_run else []
           }
       
       def _parse_csv(self, csv_content: str) -> List[Dict]:
           """Parse CSV content into list of dictionaries."""
           try:
               csv_file = StringIO(csv_content)
               reader = csv.DictReader(csv_file)
               
               # Validate headers
               if not all(field in reader.fieldnames for field in self.REQUIRED_FIELDS):
                   self.errors.append(
                       f"Missing required fields. Required: {', '.join(self.REQUIRED_FIELDS)}"
                   )
                   return []
               
               return list(reader)
           
           except Exception as e:
               self.errors.append(f"CSV parsing error: {str(e)}")
               return []
       
       def _validate_users(self, users_data: List[Dict]) -> List[Dict]:
           """Validate user data."""
           validated = []
           
           for row_num, user_data in enumerate(users_data, start=2):  # Start at 2 (header is row 1)
               # Check required fields
               if not all(user_data.get(field) for field in self.REQUIRED_FIELDS):
                   self.errors.append(
                       f"Row {row_num}: Missing required fields"
                   )
                   continue
               
               # Validate email format
               email = user_data['email'].strip().lower()
               if not self._is_valid_email(email):
                   self.errors.append(f"Row {row_num}: Invalid email format")
                   continue
               
               # Check for duplicate email
               if User.objects.filter(email=email).exists():
                   self.warnings.append(
                       f"Row {row_num}: User with email {email} already exists"
                   )
                   continue
               
               # Validate organization
               org_name = user_data['organization'].strip()
               try:
                   organization = Organization.objects.get(name__iexact=org_name)
               except Organization.DoesNotExist:
                   self.errors.append(
                       f"Row {row_num}: Organization '{org_name}' not found"
                   )
                   continue
               
               # Validate role (if provided)
               role = user_data.get('role', 'staff').strip().lower()
               valid_roles = ['admin', 'manager', 'staff', 'viewer']
               if role not in valid_roles:
                   self.warnings.append(
                       f"Row {row_num}: Invalid role '{role}', defaulting to 'staff'"
                   )
                   role = 'staff'
               
               # Add validated user
               validated.append({
                   'email': email,
                   'first_name': user_data['first_name'].strip(),
                   'last_name': user_data['last_name'].strip(),
                   'organization': organization,
                   'role': role,
                   'phone_number': user_data.get('phone_number', '').strip(),
                   'position': user_data.get('position', '').strip(),
                   'row_num': row_num
               })
           
           return validated
       
       @transaction.atomic
       def _create_users(self, validated_users: List[Dict]) -> Tuple[List[User], int]:
           """Create users in database."""
           created_users = []
           skipped = 0
           rbac_service = RBACService()
           
           for user_data in validated_users:
               try:
                   # Create user
                   user = User.objects.create_user(
                       email=user_data['email'],
                       username=user_data['email'],  # Use email as username
                       first_name=user_data['first_name'],
                       last_name=user_data['last_name'],
                       organization=user_data['organization']
                   )
                   
                   # Set optional fields
                   if user_data.get('phone_number'):
                       user.phone_number = user_data['phone_number']
                   if user_data.get('position'):
                       user.position = user_data['position']
                   
                   # Generate temporary password
                   temp_password = User.objects.make_random_password(length=12)
                   user.set_password(temp_password)
                   user.force_password_change = True
                   user.save()
                   
                   # Assign role
                   role = user_data['role']
                   rbac_service.assign_role_to_user(user, role)
                   
                   # Store temp password for email
                   user.temp_password = temp_password
                   created_users.append(user)
               
               except Exception as e:
                   self.errors.append(
                       f"Row {user_data['row_num']}: Failed to create user - {str(e)}"
                   )
                   skipped += 1
           
           return created_users, skipped
       
       def _is_valid_email(self, email: str) -> bool:
           """Basic email validation."""
           import re
           pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
           return re.match(pattern, email) is not None
   ```

2. Bulk Import View:
   File: src/accounts/views/bulk_import.py
   ```python
   from django.contrib.auth.decorators import login_required
   from django.shortcuts import render, redirect
   from django.contrib import messages
   from accounts.services.bulk_user_import import BulkUserImportService
   from accounts.forms import BulkUserImportForm
   
   @login_required
   def bulk_user_import_view(request):
       """View for bulk user import."""
       if request.method == 'POST':
           form = BulkUserImportForm(request.POST, request.FILES)
           if form.is_valid():
               csv_file = request.FILES['csv_file']
               dry_run = form.cleaned_data.get('dry_run', False)
               
               # Read CSV content
               try:
                   csv_content = csv_file.read().decode('utf-8')
               except UnicodeDecodeError:
                   messages.error(request, 'Invalid CSV file encoding')
                   return redirect('bulk_user_import')
               
               # Import users
               service = BulkUserImportService(dry_run=dry_run)
               result = service.import_from_csv(csv_content)
               
               # Display results
               if result['success']:
                   if dry_run:
                       messages.info(
                           request,
                           f"DRY RUN: Would create {result['created']} users "
                           f"({result['skipped']} skipped)"
                       )
                   else:
                       messages.success(
                           request,
                           f"Successfully created {result['created']} users "
                           f"({result['skipped']} skipped)"
                       )
                       
                       # Send welcome emails
                       if form.cleaned_data.get('send_welcome_emails'):
                           # TODO: Implement in next task
                           pass
               else:
                   messages.error(
                       request,
                       f"Import failed with {len(result['errors'])} errors"
                   )
               
               # Show errors and warnings
               for error in result['errors']:
                   messages.error(request, error)
               for warning in result['warnings']:
                   messages.warning(request, warning)
               
               return redirect('bulk_user_import')
       else:
           form = BulkUserImportForm()
       
       context = {
           'form': form,
           'csv_template': _generate_csv_template()
       }
       return render(request, 'accounts/bulk_import.html', context)
   
   
   def _generate_csv_template() -> str:
       """Generate CSV template for download."""
       return """email,first_name,last_name,organization,role,phone_number,position
user1@example.com,Juan,Dela Cruz,OOBC,staff,+639123456789,Project Officer
user2@example.com,Maria,Santos,OOBC,manager,+639987654321,Department Head"""
   ```

3. CSV Template Download:
   File: src/templates/accounts/bulk_import.html
   ```html
   {% extends "base.html" %}
   
   {% block content %}
   <div class="container mx-auto px-4 py-8">
       <h1 class="text-3xl font-bold mb-6">Bulk User Import</h1>
       
       <!-- Instructions -->
       <div class="card mb-6 bg-blue-50">
           <h2 class="text-xl font-bold mb-4">Instructions</h2>
           <ol class="list-decimal list-inside space-y-2">
               <li>Download the CSV template below</li>
               <li>Fill in user information (one user per row)</li>
               <li>Upload the completed CSV file</li>
               <li>Review the validation results</li>
               <li>Confirm import to create users</li>
           </ol>
           
           <div class="mt-4">
               <a href="{% url 'download_csv_template' %}" 
                  class="btn btn-outline"
                  download="user_import_template.csv">
                   Download CSV Template
               </a>
           </div>
       </div>
       
       <!-- Required Fields -->
       <div class="card mb-6">
           <h2 class="text-xl font-bold mb-4">Required Fields</h2>
           <ul class="list-disc list-inside space-y-1">
               <li><strong>email</strong>: Valid email address</li>
               <li><strong>first_name</strong>: User's first name</li>
               <li><strong>last_name</strong>: User's last name</li>
               <li><strong>organization</strong>: Exact organization name</li>
           </ul>
           
           <h3 class="text-lg font-bold mt-4 mb-2">Optional Fields</h3>
           <ul class="list-disc list-inside space-y-1">
               <li><strong>role</strong>: admin, manager, staff, or viewer (default: staff)</li>
               <li><strong>phone_number</strong>: Contact number</li>
               <li><strong>position</strong>: Job title/position</li>
           </ul>
       </div>
       
       <!-- Upload Form -->
       <div class="card">
           <form method="post" enctype="multipart/form-data">
               {% csrf_token %}
               
               <div class="mb-4">
                   {{ form.csv_file.label_tag }}
                   {{ form.csv_file }}
                   {% if form.csv_file.errors %}
                   <div class="text-red-600 text-sm mt-1">
                       {{ form.csv_file.errors }}
                   </div>
                   {% endif %}
               </div>
               
               <div class="mb-4">
                   <label class="flex items-center">
                       {{ form.dry_run }}
                       <span class="ml-2">Dry run (validate only, don't create users)</span>
                   </label>
               </div>
               
               <div class="mb-4">
                   <label class="flex items-center">
                       {{ form.send_welcome_emails }}
                       <span class="ml-2">Send welcome emails with login credentials</span>
                   </label>
               </div>
               
               <button type="submit" class="btn btn-primary">
                   Import Users
               </button>
           </form>
       </div>
   </div>
   {% endblock %}
   ```

VERIFICATION:
- [ ] CSV parsing works correctly
- [ ] Validation catches all errors
- [ ] Duplicate detection works
- [ ] Users created with correct data
- [ ] Dry-run mode functions properly
- [ ] Error messages are clear

================================================================================

[Remaining tasks continue with same structure...]

Due to length constraints, I'll note that the file would continue with:

SECTION 3 (continued):
- [P8-USER-002] CSV Import with Validation
- [P8-USER-003] Role Assignment Templates
- [P8-USER-004] Organization Assignment Automation
- [P8-USER-005] Welcome Email Automation
- [P8-USER-006] Credential Distribution System

SECTION 4: TRAINING AUTOMATION
- [P8-TRAIN-001] Training Session Scheduler
- [P8-TRAIN-002] Attendance Tracking
- [P8-TRAIN-003] Certificate Generation
- [P8-TRAIN-004] Training Completion Tracking
- [P8-TRAIN-005] Automated Reminder Emails
- [P8-TRAIN-006] Training Material Versioning

SECTION 5: SUPPORT INFRASTRUCTURE
- [P8-SUPPORT-001] Help Desk Scaling
- [P8-SUPPORT-002] Support Team Expansion Plan
- [P8-SUPPORT-003] Knowledge Base Expansion
- [P8-SUPPORT-004] Self-Service Portal
- [P8-SUPPORT-005] Support Analytics Dashboard
- [P8-SUPPORT-006] Support Quality Metrics

SECTION 6: MONITORING & OBSERVABILITY
- [P8-MONITOR-001] Application Performance Monitoring
- [P8-MONITOR-002] Database Query Monitoring
- [P8-MONITOR-003] User Behavior Analytics
- [P8-MONITOR-004] Feature Usage Tracking
- [P8-MONITOR-005] Error Rate Monitoring
- [P8-MONITOR-006] Uptime Monitoring
- [P8-MONITOR-007] Alert Configuration
- [P8-MONITOR-008] On-Call Procedures

SECTION 7: SUCCESS METRICS DASHBOARD
- [P8-METRICS-001] User Adoption Tracking
- [P8-METRICS-002] Active User Metrics
- [P8-METRICS-003] Feature Utilization Rates
- [P8-METRICS-004] Training Completion Rates
- [P8-METRICS-005] Support Ticket Metrics
- [P8-METRICS-006] System Performance Metrics
- [P8-METRICS-007] Rollout Progress Tracking

SECTION 8: COMMUNICATION SYSTEM
- [P8-COMM-001] System Announcement Features
- [P8-COMM-002] Maintenance Notification System
- [P8-COMM-003] User Newsletter Infrastructure
- [P8-COMM-004] Status Page Setup
- [P8-COMM-005] Incident Communication Plan

SECTION 9: ROLLOUT AUTOMATION
- [P8-AUTO-001] Organization Activation Scripts
- [P8-AUTO-002] Feature Flag System
- [P8-AUTO-003] Gradual Rollout Controls
- [P8-AUTO-004] Rollback Automation
- [P8-AUTO-005] Health Check Automation
- [P8-AUTO-006] Deployment Pipeline

================================================================================
END OF PHASE 8 PREPARATION TASKS
================================================================================

NEXT STEPS AFTER PHASE 8 PREPARATION:
1. Execute Phase 8 pilot with 3 MOAs
2. Collect metrics and lessons learned
3. Begin Wave 1 rollout (5 MOAs)
4. Continue waves until all 44 MOAs onboarded
5. Enter steady-state operations with ongoing support

CRITICAL SUCCESS FACTORS:
- Infrastructure must scale smoothly
- Automation reduces manual effort by 80%+
- Support team handles 100+ tickets per wave
- Monitoring detects issues before users report
- Communication keeps stakeholders informed
- Rollout waves complete on schedule

FILE: docs/plans/bmms/tasks/phase8_rollout_infrastructure_detailed.txt
