================================================================================
WORK ITEM DELETION PERFORMANCE ANALYSIS - QUICK REFERENCE
================================================================================

CRITICAL ISSUE: Work item deletion takes 15-30 seconds for large trees
ROOT CAUSE: Multiple inefficient cache invalidation operations compound

================================================================================
THE 5 BOTTLENECKS
================================================================================

1. N+1 USER QUERY (CRITICAL)
   Location: /Users/saidamenmambayao/apps/obcms/src/common/views/work_items.py:75
   Problem: User.objects.values_list('id', flat=True) fetches ALL users
   Impact: 5,000 cache operations for 500 users with 8 ancestors
   Time: 2.5 seconds just for cache invalidation

2. GLOBAL CACHE.CLEAR() (CRITICAL)
   Location: /Users/saidamenmambayao/apps/obcms/src/common/services/calendar.py:44
   Problem: cache.clear() destroys ENTIRE cache, not just calendar
   Impact: Forces regeneration of all cached data across application
   Called: 100+ times if deleting parent with 100 children (via signal)

3. DUPLICATE CACHE INVALIDATION (CRITICAL)
   Location: /Users/saidamenmambayao/apps/obcms/src/common/views/work_items.py:701-712
   Problem: Tree cache invalidation + signal handler both call cache.clear()
   Impact: Redundant cache destruction
   Result: cache.clear() called 2x, plus 100 times per child deletion

4. SIGNAL CASCADE (HIGH)
   Location: /Users/saidamenmambayao/apps/obcms/src/common/signals.py:108-112
   Problem: post_delete signal calls _invalidate_calendar_cache() 100+ times
   Impact: 100 global cache clears for one parent deletion
   Called: Once for parent + once per each child cascade delete

5. NO BATCH DELETE (HIGH)
   Location: /Users/saidamenmambayao/apps/obcms/src/common/work_item_model.py:95-102
   Problem: CASCADE delete generates one query per child (no batching)
   Impact: 100 children = 100+ database queries
   Time: Additional 2-5 seconds for cascade operations

================================================================================
EXPECTED PERFORMANCE IMPACT
================================================================================

Scenario                          Before    After    Improvement
Delete task (500 users)           2.5s      0.1s     96%
Delete project (10 children)      5-8s      0.2s     97%
Delete large project (100 child)  20-30s    0.5s     98%

================================================================================
SPECIFIC LINE NUMBERS AND PROBLEMS
================================================================================

FILE: /Users/saidamenmambayao/apps/obcms/src/common/views/work_items.py
------
Lines 75:   user_ids = User.objects.values_list('id', flat=True)
            PROBLEM: Queries all users instead of using version increments

Lines 78-80: for user_id in user_ids: cache.delete(...)
             PROBLEM: O(N) loop - multiplied by ancestors

Lines 89:    for ancestor in work_item.get_ancestors():
             PROBLEM: Query inside triple-nested loop

Line 701:    invalidate_work_item_tree_cache(work_item)
             PROBLEM: Runs before deletion (5,000 cache ops)

Line 703:    work_item.delete()
             PROBLEM: Triggers signal 100+ times for children

Line 706:    invalidate_calendar_cache(request.user.id)
             PROBLEM: Redundant call (signal already invalidated)


FILE: /Users/saidamenmambayao/apps/obcms/src/common/services/calendar.py
------
Line 44:     cache.clear()
             PROBLEM: Destroys ENTIRE cache, not just calendar


FILE: /Users/saidamenmambayao/apps/obcms/src/common/signals.py
------
Line 108:    @receiver([post_save, post_delete], sender=WorkItem)
Line 109:    def calendar_cache_invalidator(sender, **kwargs):
Line 112:    _invalidate_calendar_cache()  # cache.clear()
             PROBLEM: Called 100+ times, each time wipes entire cache


FILE: /Users/saidamenmambayao/apps/obcms/src/common/work_item_model.py
------
Line 95:     parent = TreeForeignKey(..., on_delete=models.CASCADE, ...)
             PROBLEM: No custom delete() method for batch operations

================================================================================
OPTIMIZATION SOLUTIONS
================================================================================

PRIORITY 1 (80% improvement):
  Replace: user_ids loop with cache version increment
  Location: /Users/saidamenmambayao/apps/obcms/src/common/views/work_items.py:75
  Code: cache.incr(f'work_tree_version:{work_item.id}')

PRIORITY 2 (60% improvement):
  Replace: cache.clear() with targeted invalidation
  Location: /Users/saidamenmambayao/apps/obcms/src/common/services/calendar.py:44
  Code: cache.incr(f'calendar_version:{user_id}')

PRIORITY 3 (40% improvement):
  Remove: Signal-based cache invalidation during deletion
  Location: /Users/saidamenmambayao/apps/obcms/src/common/signals.py:108-112
  Code: Add condition to skip if _skip_cache_invalidation flag set

PRIORITY 4 (30% improvement):
  Add: Custom delete() method with batch operations
  Location: /Users/saidamenmambayao/apps/obcms/src/common/work_item_model.py
  Code: Override delete() to batch delete descendants

PRIORITY 5 (15% improvement):
  Cache: Ancestors before deletion
  Location: /Users/saidamenmambayao/apps/obcms/src/common/views/work_items.py:53
  Code: ancestor_ids = list(work_item.get_ancestors().values_list('id'))

================================================================================
DETAILED ANALYSIS DOCUMENT
================================================================================

Full analysis with code examples and implementation details:
/Users/saidamenmambayao/apps/obcms/docs/performance/20251021-1430-work-item-deletion-performance-analysis.md

================================================================================
Generated: 2025-10-21 14:30
================================================================================
